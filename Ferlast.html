
<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<title>Ferlast</title>
<link rel="icon" href="profile.png">
<style>

</style>
</head>
<body>
<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Realtime Chat + Friends + Video Call</title>
  <style>
    /* Base and responsiveness */
    :root {
      --bg: #0f172a; --panel: #111827; --muted: #6b7280;
      --text: #e5e7eb; --accent: #22c55e; --warn: #ef4444;
      --border: #1f2937;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans Thai", sans-serif;
      background: linear-gradient(180deg, #0b1023, #0f172a);
      color: var(--text);
    }
    header, footer {
      padding: 12px 16px; background: #0b1222; border-bottom: 1px solid var(--border);
    }
    header h1 { margin: 0; font-size: 18px; }
    .container {
      display: grid; grid-template-columns: 280px 1fr; gap: 12px;
      padding: 12px; height: calc(100vh - 88px);
    }
    .panel {
      background: var(--panel); border: 1px solid var(--border);
      border-radius: 10px; overflow: hidden;
    }
    .panel h2 {
      margin: 0; padding: 12px 12px; font-size: 14px;
      border-bottom: 1px solid var(--border); color: var(--muted);
    }
    .stack { display: grid; gap: 10px; padding: 12px; }
    input, button, select, textarea {
      border-radius: 8px; border: 1px solid var(--border);
      background: #0f172a; color: var(--text); padding: 10px; font-size: 14px;
    }
    button.accent { background: var(--accent); color: #042010; border-color: #16a34a; }
    button.warn { background: var(--warn); border-color: #b91c1c; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .row { display: flex; gap: 10px; align-items: center; }
    .grow { flex: 1; }
    .muted { color: var(--muted); font-size: 12px; }
    .list { max-height: 40vh; overflow: auto; display: grid; gap: 6px; }
    .item {
      display: grid; grid-template-columns: 1fr auto; gap: 6px; align-items: center;
      padding: 8px; border: 1px solid var(--border); border-radius: 8px; background: #0b1428;
    }
    .item .name { font-weight: 600; }
    .chat {
      display: grid; grid-template-rows: auto 1fr auto; height: 100%;
    }
    .messages { overflow-y: auto; padding: 12px; display: grid; gap: 8px; }
    .bubble {
      max-width: 70%; padding: 10px; border-radius: 12px;
      background: #0b1428; border: 1px solid var(--border); word-wrap: break-word;
    }
    .bubble.me { justify-self: end; background: #0e2b17; border-color: #14532d; }
    .bubble .meta { font-size: 11px; color: var(--muted); margin-top: 4px; }
    .compose { padding: 10px; display: grid; grid-template-columns: 1fr auto; gap: 8px; }
    .callbar { padding: 8px; border-top: 1px solid var(--border); display: flex; gap: 8px; align-items: center; }
    video { width: 48%; max-height: 30vh; background: #000; border-radius: 8px; }
    @media (max-width: 900px) {
      .container { grid-template-columns: 1fr; height: auto; min-height: calc(100vh - 88px); }
      .list { max-height: none; }
      .callbar { flex-wrap: wrap; }
      video { width: 100%; max-height: 35vh; }
    }
    /* Login overlay */
    #loginOverlay {
      position: fixed; inset: 0; background: rgba(5,10,25,0.9);
      display: grid; place-items: center; z-index: 20;
    }
    #loginCard {
      width: min(520px, 94vw);
      background: var(--panel); border: 1px solid var(--border); border-radius: 12px;
      padding: 16px; display: grid; gap: 12px;
    }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#0b1428; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>

<header>
  <h1>Chat + Friends + Video</h1>
</header>

<!-- Login -->
<div id="loginOverlay" aria-modal="true" role="dialog">
  <div id="loginCard">
    <h2>ตั้งชื่อแสดงผลเพื่อเริ่มแชท</h2>
    <div class="stack">
      <div class="row">
        <input id="displayName" class="grow" placeholder="เช่น asus" autocomplete="nickname" />
        <button id="startBtn" class="accent">เริ่มใช้งาน</button>
      </div>
      <p class="muted">
        ระบบจะสร้างบัญชีแบบนิรนามที่ปลอดภัยให้คุณ และบันทึกไว้ในอุปกรณ์นี้อย่างถาวร
        กลับมาอีกครั้งคุณจะอยู่ในหน้าแชทเหมือนเดิม เพื่อนไม่หาย
      </p>
      <p class="muted">
        ชื่อแสดงผลสามารถซ้ำกับคนอื่นได้ หากอยากล็อกไม่ให้ซ้ำ ให้เปิด “ล็อกชื่อนี้” ด้านล่าง
      </p>
      <label class="row">
        <input type="checkbox" id="enforceUnique" />
        <span>ล็อกชื่อนี้ไม่ให้ซ้ำ</span>
      </label>
    </div>
  </div>
</div>

<div class="container" aria-live="polite">
  <!-- Left: friends and requests -->
  <section class="panel">
    <h2>เพื่อนและคำขอ</h2>
    <div class="stack">
      <div class="row">
        <input id="searchUser" class="grow" placeholder="ค้นหาชื่อเพื่อแอดเพื่อน" />
        <button id="addFriendBtn">แอดเพื่อน</button>
      </div>
      <div>
        <div class="muted">เพื่อน</div>
        <div id="friendsList" class="list"></div>
      </div>
      <div>
        <div class="muted">คำขอที่เข้ามา</div>
        <div id="requestsList" class="list"></div>
      </div>
      <div class="row">
        <button id="logoutBtn" class="warn">ออกจากระบบ (ยังคงบัญชีในเครื่องนี้)</button>
        <span class="muted">UID: <span id="uidLabel" class="kbd"></span></span>
      </div>
    </div>
  </section>

  <!-- Right: chat -->
  <section class="panel chat" aria-label="พื้นที่แชท">
    <h2 id="chatTitle">เลือกเพื่อนเพื่อเริ่มแชท</h2>
    <div id="messages" class="messages"></div>
    <div class="compose">
      <input id="messageInput" placeholder="พิมพ์ข้อความ..." />
      <button id="sendBtn" class="accent">ส่ง</button>
    </div>
    <div class="callbar">
      <button id="startCallBtn">เริ่มวีดีโอคอล</button>
      <button id="hangupBtn" class="warn" disabled>วางสาย</button>
      <span id="callStatus" class="muted">พร้อมคุย</span>
      <div class="row" style="margin-left:auto">
        <button id="muteBtn">ปิด/เปิดไมค์</button>
        <button id="cameraBtn">ปิด/เปิดกล้อง</button>
      </div>
    </div>
    <div class="row" style="padding:8px">
      <video id="localVideo" autoplay playsinline muted></video>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>
  </section>
</div>

<footer>
  <span class="muted">บันทึกทุกอย่างแบบเรียลไทม์ ปลอดภัย และรองรับมือถือ</span>
</footer>

<script type="module">
  // ===== Firebase bootstrap =====
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
  import {
    getDatabase, ref, get, set, push, onValue, onChildAdded,
    update, runTransaction, serverTimestamp, onDisconnect, remove
  } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";
  import {
    getAuth, onAuthStateChanged, signInAnonymously, signOut
  } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "YOUR-API-KEY",
    authDomain: "YOUR-PROJECT.firebaseapp.com",
    databaseURL: "https://YOUR-PROJECT-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "YOUR-PROJECT",
    storageBucket: "YOUR-PROJECT.appspot.com",
    messagingSenderId: "YOUR-SENDER-ID",
    appId: "YOUR-APP-ID"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const auth = getAuth(app);

  // ===== DOM refs =====
  const loginOverlay = document.getElementById('loginOverlay');
  const displayNameInput = document.getElementById('displayName');
  const enforceUnique = document.getElementById('enforceUnique');
  const startBtn = document.getElementById('startBtn');
  const uidLabel = document.getElementById('uidLabel');

  const searchUserInput = document.getElementById('searchUser');
  const addFriendBtn = document.getElementById('addFriendBtn');
  const friendsList = document.getElementById('friendsList');
  const requestsList = document.getElementById('requestsList');

  const chatTitle = document.getElementById('chatTitle');
  const messagesEl = document.getElementById('messages');
  const messageInput = document.getElementById('messageInput');
  const sendBtn = document.getElementById('sendBtn');
  const logoutBtn = document.getElementById('logoutBtn');

  const startCallBtn = document.getElementById('startCallBtn');
  const hangupBtn = document.getElementById('hangupBtn');
  const callStatus = document.getElementById('callStatus');
  const muteBtn = document.getElementById('muteBtn');
  const cameraBtn = document.getElementById('cameraBtn');
  const localVideo = document.getElementById('localVideo');
  const remoteVideo = document.getElementById('remoteVideo');

  // ===== State =====
  let currentUser = { uid: null, name: null };
  let currentChatPeer = null; // peer uid
  let currentChatId = null;

  // WebRTC state
  let pc = null;
  let localStream = null;
  const rtcConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

  // ===== Utilities =====
  const chatIdFor = (a, b) => [a, b].sort().join('_');
  const userRef = (uid) => ref(db, `users/${uid}`);
  const usernameIndexRef = (name) => ref(db, `usernames/${name.toLowerCase()}`);
  const friendsRef = (uid) => ref(db, `friends/${uid}`);
  const requestsRef = (uid) => ref(db, `friendRequests/${uid}`);
  const chatRef = (chatId) => ref(db, `chats/${chatId}/messages`);
  const presenceRef = (uid) => ref(db, `presence/${uid}`);
  const callsRef = (chatId) => ref(db, `calls/${chatId}`);

  const fmt = (ts) => {
    try {
      return new Date(ts).toLocaleString();
    } catch { return '' }
  }

  // ===== Auth + session =====
  const persisted = JSON.parse(localStorage.getItem('session') || 'null');

  const startSession = async (name, unique) => {
    await signInAnonymously(auth);
    // Wait for auth state to set uid
    return new Promise((resolve) => {
      const unsub = onAuthStateChanged(auth, async (u) => {
        if (!u) return;
        currentUser.uid = u.uid;
        currentUser.name = name.trim() || `user_${u.uid.slice(-6)}`;

        // Optional: enforce unique display name
        if (unique) {
          await runTransaction(usernameIndexRef(currentUser.name), (cur) => {
            if (cur === null) return { uid: currentUser.uid }; // reserve
            return cur; // already taken
          }).then(async (res) => {
            if (!res.committed || (res.snapshot.val()?.uid && res.snapshot.val().uid !== currentUser.uid)) {
              alert('ชื่อนี้มีคนใช้แล้ว โปรดเลือกชื่ออื่น');
              await signOut(auth);
              return resolve(false);
            }
          });
        }

        // Write user profile
        await set(userRef(currentUser.uid), {
          displayName: currentUser.name,
          createdAt: Date.now()
        });

        // Presence
        await set(presenceRef(currentUser.uid), { online: true, lastSeen: Date.now() });
        onDisconnect(presenceRef(currentUser.uid)).set({ online: false, lastSeen: Date.now() });

        // Persist locally
        localStorage.setItem('session', JSON.stringify({
          uid: currentUser.uid,
          name: currentUser.name,
          unique
        }));

        uidLabel.textContent = currentUser.uid;
        loginOverlay.style.display = 'none';
        attachRealtimeListeners();
        resolve(true);
        unsub();
      });
    });
  };

  const restoreSession = async () => {
    if (!persisted) return false;
    displayNameInput.value = persisted.name || '';
    enforceUnique.checked = !!persisted.unique;
    // Anonymous sign-in again (new token), but keep same local identity
    await signInAnonymously(auth);
    return new Promise((resolve) => {
      const unsub = onAuthStateChanged(auth, async (u) => {
        if (!u) return;
        currentUser.uid = u.uid; // new anon uid; bind logical identity by name
        currentUser.name = persisted.name || `user_${u.uid.slice(-6)}`;

        // If uniqueness was requested, try to claim (idempotent)
        if (persisted.unique) {
          await runTransaction(usernameIndexRef(currentUser.name), (cur) => {
            if (cur === null) return { uid: currentUser.uid };
            return cur;
          });
        }
        await set(userRef(currentUser.uid), {
          displayName: currentUser.name, restoredAt: Date.now()
        });
        await set(presenceRef(currentUser.uid), { online: true, lastSeen: Date.now() });
        onDisconnect(presenceRef(currentUser.uid)).set({ online: false, lastSeen: Date.now() });

        uidLabel.textContent = currentUser.uid;
        loginOverlay.style.display = 'none';
        attachRealtimeListeners();
        resolve(true);
        unsub();
      });
    });
  };

  // ===== Friends and requests =====
  const renderListItem = (name, uid, actions = []) => {
    const div = document.createElement('div');
    div.className = 'item';
    const left = document.createElement('div');
    left.innerHTML = `<div class="name">${name}</div><div class="muted">${uid}</div>`;
    const right = document.createElement('div');
    actions.forEach(a => {
      const btn = document.createElement('button');
      btn.textContent = a.label;
      if (a.class) btn.classList.add(a.class);
      btn.onclick = a.onClick;
      right.appendChild(btn);
    });
    div.appendChild(left);
    div.appendChild(right);
    return div;
  };

  const attachRealtimeListeners = () => {
    // Incoming friend requests
    onChildAdded(requestsRef(currentUser.uid), (snap) => {
      const fromUid = snap.key;
      get(userRef(fromUid)).then(s => {
        const name = s.val()?.displayName || fromUid.slice(-6);
        const item = renderListItem(name, fromUid, [
          { label: 'รับ', class: 'accent', onClick: () => acceptRequest(fromUid) },
          { label: 'ปฏิเสธ', class: 'warn', onClick: () => declineRequest(fromUid) },
        ]);
        item.dataset.uid = fromUid;
        requestsList.appendChild(item);
      });
    });

    // Friends list
    onChildAdded(friendsRef(currentUser.uid), (snap) => {
      const peerUid = snap.key;
      const status = snap.val()?.status;
      if (status !== 'accepted') return;
      get(userRef(peerUid)).then(s => {
        const name = s.val()?.displayName || peerUid.slice(-6);
        const item = renderListItem(name, peerUid, [
          { label: 'แชท', class: 'accent', onClick: () => openChat(peerUid, name) },
          { label: 'ลบเพื่อน', class: 'warn', onClick: () => removeFriend(peerUid) },
        ]);
        item.dataset.uid = peerUid;
        friendsList.appendChild(item);
      });
    });
  };

  const sendFriendRequest = async (targetName) => {
    const qName = targetName.trim().toLowerCase();
    if (!qName) return alert('กรุณากรอกชื่อเพื่อแอดเพื่อน');
    // Find by username index (may be non-unique -> pick first)
    const idxSnap = await get(ref(db, 'usernames'));
    let targetUid = null;
    const all = idxSnap.val() || {};
    for (const [name, obj] of Object.entries(all)) {
      if (name === qName) { targetUid = obj.uid; break; }
    }
    if (!targetUid) return alert('ไม่พบผู้ใช้ชื่อนี้ หรือเขายังไม่ล็อกชื่อไว้');

    if (targetUid === currentUser.uid) return alert('ไม่สามารถแอดตัวเองเป็นเพื่อนได้');

    await set(ref(db, `friendRequests/${targetUid}/${currentUser.uid}`), {
      at: Date.now()
    });
    alert('ส่งคำขอเพื่อนแล้ว');
  };

  const acceptRequest = async (fromUid) => {
    const me = currentUser.uid;
    await update(ref(db, `friends/${me}/${fromUid}`), { status: 'accepted', at: Date.now() });
    await update(ref(db, `friends/${fromUid}/${me}`), { status: 'accepted', at: Date.now() });
    await remove(ref(db, `friendRequests/${me}/${fromUid}`));
  };

  const declineRequest = async (fromUid) => {
    const me = currentUser.uid;
    await remove(ref(db, `friendRequests/${me}/${fromUid}`));
  };

  const removeFriend = async (peerUid) => {
    const me = currentUser.uid;
    await remove(ref(db, `friends/${me}/${peerUid}`));
    await remove(ref(db, `friends/${peerUid}/${me}`));
    // If this friend was the open chat, clear it
    if (currentChatPeer === peerUid) {
      currentChatPeer = null;
      currentChatId = null;
      chatTitle.textContent = 'เลือกเพื่อนเพื่อเริ่มแชท';
      messagesEl.innerHTML = '';
    }
  };

  // ===== Chat =====
  const openChat = async (peerUid, peerName) => {
    currentChatPeer = peerUid;
    currentChatId = chatIdFor(currentUser.uid, peerUid);
    chatTitle.textContent = `คุยกับ ${peerName}`;
    messagesEl.innerHTML = '';

    // Listen to messages
    onValue(chatRef(currentChatId), (snap) => {
      messagesEl.innerHTML = '';
      const msgs = snap.val() || {};
      const sorted = Object.values(msgs).sort((a,b) => (a.at||0)-(b.at||0));
      sorted.forEach(m => {
        const b = document.createElement('div');
        b.className = 'bubble' + (m.from === currentUser.uid ? ' me' : '');
        b.innerHTML = `
          <div>${(m.text || '').replace(/</g,'&lt;')}</div>
          <div class="meta">${fmt(m.at)} • ${m.from === currentUser.uid ? 'ฉัน' : 'เขา'}</div>`;
        messagesEl.appendChild(b);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      });
    });
  };

  const sendMessage = async () => {
    if (!currentChatId) return alert('โปรดเลือกเพื่อนเพื่อเริ่มแชท');
    const text = messageInput.value.trim();
    if (!text) return;
    await push(chatRef(currentChatId), {
      from: currentUser.uid, text, at: Date.now()
    });
    messageInput.value = '';
  };

  // ===== WebRTC calls (signaling via Firebase) =====
  const setupPeer = () => {
    pc = new RTCPeerConnection(rtcConfig);
    pc.ontrack = (e) => { remoteVideo.srcObject = e.streams[0]; };
    pc.onicecandidate = (e) => {
      if (e.candidate && currentChatId) {
        push(ref(db, `calls/${currentChatId}/candidates/${currentUser.uid}`), e.candidate.toJSON());
      }
    };
  };

  const listenForCalls = () => {
    if (!currentChatId) return;
    // Offers from peer
    onChildAdded(ref(db, `calls/${currentChatId}/offers`), async (snap) => {
      const offer = snap.val();
      if (offer.to !== currentUser.uid) return;
      await ensureMedia();
      setupPeer();
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      await pc.setRemoteDescription(offer.sdp);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await push(ref(db, `calls/${currentChatId}/answers`), {
        from: currentUser.uid, to: offer.from, sdp: pc.localDescription, at: Date.now()
      });
      callStatus.textContent = 'กำลังเชื่อมต่อ...';
      hangupBtn.disabled = false;
      // ICE candidates from peer
      onChildAdded(ref(db, `calls/${currentChatId}/candidates/${offer.from}`), async (cSnap) => {
        const cand = cSnap.val();
        try { await pc.addIceCandidate(cand); } catch {}
      });
    });

    // Answers to my offer
    onChildAdded(ref(db, `calls/${currentChatId}/answers`), async (snap) => {
      const ans = snap.val();
      if (ans.to !== currentUser.uid) return;
      await pc?.setRemoteDescription(ans.sdp);
      callStatus.textContent = 'เชื่อมต่อสำเร็จ';
      hangupBtn.disabled = false;
      // ICE candidates from peer
      onChildAdded(ref(db, `calls/${currentChatId}/candidates/${ans.from}`), async (cSnap) => {
        const cand = cSnap.val();
        try { await pc.addIceCandidate(cand); } catch {}
      });
    });
  };

  const ensureMedia = async () => {
    if (localStream) return localStream;
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = localStream;
    return localStream;
  };

  const startCall = async () => {
    if (!currentChatPeer) return alert('โปรดเปิดแชทกับเพื่อนก่อนเริ่มคอล');
    await ensureMedia();
    setupPeer();
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await push(ref(db, `calls/${currentChatId}/offers`), {
      from: currentUser.uid, to: currentChatPeer, sdp: pc.localDescription, at: Date.now()
    });
    callStatus.textContent = 'ส่งคำเชิญคอล...';
    listenForCalls();
  };

  const hangup = async () => {
    try { pc?.getSenders()?.forEach(s => s.track?.stop()); } catch {}
    try { pc?.close(); } catch {}
    pc = null; localStream = null;
    localVideo.srcObject = null; remoteVideo.srcObject = null;
    callStatus.textContent = 'พร้อมคุย';
    hangupBtn.disabled = true;
    if (currentChatId) await remove(ref(db, `calls/${currentChatId}`));
  };

  const toggleMic = () => {
    localStream?.getAudioTracks()?.forEach(t => t.enabled = !t.enabled);
  };
  const toggleCam = () => {
    localStream?.getVideoTracks()?.forEach(t => t.enabled = !t.enabled);
  };

  // ===== Events =====
  startBtn.onclick = async () => {
    const ok = await startSession(displayNameInput.value, enforceUnique.checked);
    if (!ok) loginOverlay.style.display = 'grid';
  };
  addFriendBtn.onclick = () => sendFriendRequest(searchUserInput.value);
  sendBtn.onclick = sendMessage;
  messageInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
  });
  logoutBtn.onclick = async () => {
    await signOut(auth);
    // keep local session; only mark offline
    await set(presenceRef(currentUser.uid), { online: false, lastSeen: Date.now() });
    alert('ออกจากระบบแล้ว แต่บัญชีนี้ยังคงอยู่ในอุปกรณ์นี้');
    loginOverlay.style.display = 'grid';
  };

  startCallBtn.onclick = startCall;
  hangupBtn.onclick = hangup;
  muteBtn.onclick = toggleMic;
  cameraBtn.onclick = toggleCam;

  // Restore session if exists
  (async () => {
    const restored = await restoreSession();
    if (!restored) loginOverlay.style.display = 'grid';
  })();
</script>

</body>
</html>
<script>

</script>
</body>
</html>
